--[[
	                                                                ,,╓╓╥╗╗@@@╣╢
	                                               ,²╓╓╥╗@@@╣╣╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒U
	                               ,,╓╓╥m╗@@@╣╢▒▒▒▒▒▒▒▒▒Ñ╜`         "╙╣▒▒▒▒▒▒▒▒╣
	               ,,╓╓╗╗╗@@╣╣╢▒▒▒▒▒▒╣╝╨╜╙"`║▒▒▒▒▒▒▒▒╢╜                `╣▒▒▒▒▒▒▒
	,╓╓╥╗@@@╣╢╢▒▒▒▒ÑÑ╝╝╨╜╨╝╝╣▒▒▒▒▒▒▒▒╢      ]▒▒▒▒▒▒▒╝         ,,         ╙▒▒▒▒▒▒
	║▒▒▒▒▒"`                  `╝▒▒▒▒▒▒       ▒▒▒▒▒▒╝      ,@▒▒▒▒▒╣╗     ╓╗╣▒▒▒▒▒[
	 ▒▒▒▒▒U                     └▒▒▒▒▒       ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒╢╗╣╣▒▒▒▒▒▒▒▒▒▒
	 ▒▒▒▒▒╣       ²╓╓╥╗╗╗╖       ]▒▒▒▒[      ]▒▒▒▒[      ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
	 ║▒▒▒▒▒       ▒▒▒▒▒▒▒▒╣      ]▒▒▒▒▒       ▒▒▒▒[      ║▒▒▒▒▒▒▒▒▒▒╢╢Ñ╝╨╜╙╙▒▒▒▒▒[
	 ]▒▒▒▒▒       ╢▒▒▒▒▒▒╢╜      ║▒▒▒▒▒       ╢▒▒▒[      ]▒▒▒▒▒[            ╢▒▒▒▒╢
	  ▒▒▒▒▒[      └╙"``         @▒▒▒▒▒▒[      ]▒▒▒╢       ▒▒▒▒▒╣            ║▒▒▒▒▒
	  ║▒▒▒▒╢                   ²╙╣▒▒▒▒▒▒       ▒▒▒▒       ║▒▒▒▒▒   ,²╓      ]▒▒▒▒▒U
	  ]▒▒▒▒▒                       ╣▒▒▒▒       ╢▒▒▒╣       ╢▒▒▒▒▒▒▒▒▒╜       ▒▒▒▒▒╣
	   ▒▒▒▒▒[      ]@╣╣▒▒▒▒╣╗       ▒▒▒▒[      ║▒▒▒▒╗       ╙╣▒▒▒▒▒Ñ`        ║▒▒▒▒▒
	   ╢▒▒▒▒╢       ▒▒▒▒▒▒▒▒▒U      ║▒▒▒╢      ]▒▒▒▒▒@                       ]▒▒▒▒▒
	   ║▒▒▒▒▒       ╣▒▒▒▒▒▒▒╢       ║▒▒▒▒       ▒▒▒▒▒▒╣╖               ,[     ▒▒▒▒▒[
	    ▒▒▒▒▒U      ║Ñ╝╨╜╙"²        ▒▒▒▒▒       ║▒▒▒▒▒▒▒▒@╖,        ,╥╣▒╢@@╣╣╢▒▒▒▒╢╢
	    ▒▒▒▒▒[                    ╓╢▒▒▒▒▒[      ]▒▒▒▒▒▒▒▒▒▒▒▒▒╢╢╢▒╢ÑÑ╝╝╜╙""`
	    ║▒▒▒▒▒                ,╓@╢▒▒▒▒▒▒▒▒@╣╣╢▒▒▒▒╢Ñ╝╝╨╜╙""`           ╓╗@@@╗╖
	    ]▒▒▒▒▒    ,,╓╓╗╗@@@╣▒▒▒▒▒▒╢ÑÑ╝╝╜╙"``        ,²╓  ╔@@@╣╣╢▒▒▒U ,╣▒Ñ╙"╙╢▒Ñ
	     ▒▒▒▒▒▒▒▒▒╢Ñ╝╝╨╜╙"``             ╥@@@╗    ]▒▒▒▒  ]▒▒╣"``     ]▒▒╗,
	     "``       ,╓╖╓,       ]▒▒▒╣     ]▒▒▒▒╖   ║▒▒▒▒[  ▒▒▒   ,,    ╙╣▒▒▒▒╣%╖
	            ,╣▒▒╢╣╣▒▒@     ╢▒▒╣▒╣     ▒▒╢╣▒╖  ▒▒[▒▒╢  ║▒▒▒▒▒▒▒r       `"╙╣▒▒╕
	            ╣▒╣    ╙╜`     ▒▒╢ ╣▒╣    ▒▒▒╙▒▒╕]▒▒ ║▒▒  ]▒▒[         ╓@     ▒▒╢
	           ║▒▒[       ,   ]▒▒[  ▒▒╣   ║▒▒ ╙▒▒@▒▒ ]▒▒L  ▒▒╢   ,,╓╓  ╣▒▒╣@╣▒▒╣
	           ]▒▒[  ]╢▒▒▒▒[  ║▒▒╣╣╣╢▒▒╣  ]▒▒[ ╙▒▒▒[  ▒▒╣  ╢▒▒▒▒▒▒▒╢Ñ~    "╙"`  		
	            ╢▒▒     ]▒▒╢  ╢▒▒╙"``╙▒▒@  ▒▒╢  ╙▒╢`  ╨╜╜  ``
	             ╣▒▒h╖╥@▒▒▒▒ j▒▒╣     ╙╜╙` `
	              `╙╝ÑÑ╝╙ "`
                                                       
    
	BIG Games rbx.lua Framework [2017] - [2021]
	Written by Preston - preston@biggames.io
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Network
	===========
	Handles all the networking from client to server. Automatically compresses strings and tables to save bandwidth (theoretical)
	Makes networking completely automatic and somehow also makes the syntax simplier. No fiddling with remotes required. B)
	
	Event example:
		CLIENT:
		_L.Network.Fire("Bullet Fired", bullet.CFrame, bullet, {speed = 33, damage = 423})
		
		SERVER:
		_L.Network.Fired("Bullet Fired"):Connect(function(player, ...)
			FireBullet(player, ...)
		end)
	
	Function example:
		CLIENT:
		local success = _L.Network.Invoke("Buy", "Super Soaker 5000", 2455)
		
		SERVER:
		_L.Network.Invoked("Buy").OnInvoke = function(player, itemName, price)
			return (price <= 3000)
		end
		
	===========
		\\\ Subsititute for RemoteEvent:FireServer() / RemoteEvent:FireClient()
		Network.Fire(
			remoteName,				<--	|REQ|	Remote name											
			player,					<-- |REQ|	Player instance	(SERVER ONLY)								
			...,					<-- 		Anything :)							
		)
	
		\\\ Subsititute for RemoteFunction:InvokeClient() / RemoteFunction:InvokeServer()
		Network.Invoke(
			remoteName,				<--	|REQ|	Remote name											
			player,					<-- |REQ|	Player instance	(SERVER ONLY)								
			...,					<-- 		Anything :)							
		)

		\\\ Subsititute for RemoteEvent.OnClientEvent / RemoteEvent.OnServerEvent
		Network.Fired(
			remoteName,				<--	|REQ|	Remote name			
		)
		
		\\\ Subsititute for RemoteFunction.OnClientInvoke / RemoteFunction.OnServerInvoke
		Network.Invoked.OnInvoke(
			remoteName,				<--	|REQ|	Remote name			
		)
		
		\\\ Subsititute for RemoteEvent:FireAllClients()
		Network.FireAll(
			remoteName,				<--	|REQ|	Remote name																		
			...,					<-- 		Anything :)							
		)
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--------|       Top       |--------
local Network = {}

--------|     Setting     |--------
local compressionEnabled = true --- disable if you want to sacrifice bandwidth for server performance. Disabling defaults to vanilla remote behavior.

--------|     Library     |--------
local _L; coroutine.wrap(function()  _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))  end)()

--------|    Reference    |--------
local isServer = _L.Services.RunService:IsServer()
local things = game.Workspace:WaitForChild("__THINGS")
local remotes = things:WaitForChild("__REMOTES")
local mainRemote = remotes:WaitForChild("MAIN")

--------|    Variables    |--------
local queue = {}
local lastQueue = tick()
local events = {}
local listening = {}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--- Fire
Network.Fire = function(remoteName, arg, ...)
	--- Variables
	remoteName = string.lower(remoteName)
	
	--- Get/create remote
	local remote = GetRemote(remoteName)
	
	--- Signal for visualization/tracking purposes on Debug (Client only)
	if not isServer then
		_L.Signal.Fire("CORE Network Fire", remoteName)
	end
	
	--- Create packet with arguments
	if isServer then
		--- Server
		local packet = CreatePacket(...)
		local player = arg
		
		--- Check if player is past intro
		if not player:FindFirstChild("__LOADED") then
			return
		end
		
		--- Send
		remote:FireClient(player, packet)
		
	else
		--- Client
		local packet = CreatePacket(arg, ...)
		
		--- Send
		remote:FireServer(packet)
	end
end


--- Fire (everyone)
Network.FireAll = function(remoteName, ...)
	--- Variables
	remoteName = string.lower(remoteName)
	
	--- Get/create remote
	local remote = GetRemote(remoteName)
	
	--- Create packet with arguments
	local packet = CreatePacket(...)
	
	--- Get a list of players loaded past intro (that we can fire event on)
	local players = game.Players:GetPlayers()
	local playersToSend = {}
	--
	for _, player in ipairs(players) do
		if player:FindFirstChild("__LOADED") then
			table.insert(playersToSend, player)
		end
	end
	
	--- Send
	if #playersToSend >= #players then
		--- Can use optimized FireAllClients
		remote:FireAllClients(packet)
	
	else
		--- Some players are in intro, so we gotta fire each manually
		for _, player in ipairs(playersToSend) do
			coroutine.wrap(function()
				remote:FireClient(player, packet)
			end)()
		end
	end
end


--- Invoke
Network.Invoke = function(remoteName, arg, ...)
	--- Variables
	remoteName = string.lower(remoteName)
	
	--- Get/create remote
	local remote = GetRemote(remoteName, true)
	
	--- Signal for visualization/tracking purposes on Debug (Client only)
	if not isServer then
		_L.Signal.Fire("CORE Network Invoke", remoteName)
	end
	
	--- Create packet with arguments
	if isServer then
		--- Server
		local packet = CreatePacket(...)
		local player = arg
		
		--- Check if player is past intro
		if not player:FindFirstChild("__LOADED") then
			return
		end
		
		--- Return decoded packet
		return DecodePacket(remote:InvokeClient(arg, packet))
		
	else
		--- Client
		local packet = CreatePacket(arg, ...)
		
		--- Return decoded packet
		return DecodePacket(remote:InvokeServer(packet))
	end
end


--- On Fire
Network.Fired = function(remoteName)
	--- Variables
	remoteName = string.lower(remoteName)
	
	--- Get/create bindableEvent
	local event = GetEvent(remoteName)
	
	--
	return event.Event
end


--- On Invoke
Network.Invoked = function(remoteName)
	--- Variables
	remoteName = string.lower(remoteName)
	
	--- Get/create bindableFunction
	local event = GetEvent(remoteName, true)
	
	--
	return event
end


--- Packet recieved from server/client
Network.Recieve = function(packetType, ...)
	--- Variables
	local data = {...}
	
	--- Direct packet info based on packetType
	if packetType == "a" then
		--- SERVER | Create remote event
		GetRemote(unpack(data))
		
	elseif packetType == "b" then
		--- SERVER | Create remote function
		GetRemote(unpack(data), true)
		
	elseif packetType == "c" then
		--- CLIENT | Recieved event
		local remoteName, packet = unpack(data)
		local event = GetEvent(remoteName)
		event:Fire(DecodePacket(packet))
		
	elseif packetType == "d" then
		--- CLIENT | Recieved invoke
		local remoteName, packet = unpack(data)
		local event = GetEvent(remoteName, true)
		return CreatePacket(event:Invoke(DecodePacket(packet)))
		
	elseif packetType == "e" then
		--- SERVER | Recieved event
		local remoteName, player, packet = unpack(data)
		local event = GetEvent(remoteName)
		event:Fire(player, DecodePacket(packet))
		
	elseif packetType == "f" then
		--- SERVER | Recieved invoke
		local remoteName, player, packet = unpack(data)
		local event = GetEvent(remoteName, true)
		return CreatePacket(event:Invoke(player, DecodePacket(packet)))
		
	else
		--- packetType returned doesn't exist :(
		_L.Print("_L.Network.Recieve | Corrupted packet (packet type recieved as [bold]" .. packetType .. "[/bold])", true)
	end
end


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--- Turn series of arguments into compressed 'packet'
function CreatePacket(...)
	--- Variables
	local newPacket = {{}, {}}
	local newPacketData = newPacket[1]
	local newPacketIndex = newPacket[2]
	
	--- Return if compression is disabled
	if not compressionEnabled then
		return ...
	end

	--- Straight up magic (lets us iterate through nil)
	local packet, _n = {...}, select("#", ...)
	
	--- Iterate through all arguments
	for i = 1, _n do
		local data = packet[i]
		
		--- Process non-nil arguments
		if data ~= nil then
			--- Eligible for compression?
			if (type(data) == "table" and (not _L.Functions.HasUserdata(data))) or (type(data) == "string" and utf8.len(data) >= 10) then
				--- Vars
				local wasTable = (type(data) == "table")
				local compressed, success, convertedToJSON
				
				--- Attempt to compress
				success = pcall(function()
					compressed, convertedToJSON = _L.Functions.Compress.Encode(data)
				end)
				
				--- Successfully compressed?
				if success and compressed and (not convertedToJSON) and (compressed ~= data) then
					--- Add!
					newPacketData[i] = compressed
					newPacketIndex[i] = (wasTable and 1 or true)
				
				else
					--- Failed to compress. Add!
					newPacketData[i] = data
					newPacketIndex[i] = false
				end
			
			else
				--- Add!
				newPacketData[i] = data
				newPacketIndex[i] = false
			end
		
		else
			--- Process nil arguments
			data = false
			newPacketData[i] = data
			newPacketIndex[i] = 2
		end
	end
	
	return newPacket
end


--- Decode previously encoded packet into a series of readable arguments
function DecodePacket(packet)
	--- Variables
	local newData = {}
	
	--- Return if compression is disabled
	if not compressionEnabled then
		return unpack(packet)
	end
	
	--- Seperate packet
	local packetData = packet[1]
	local packetIndex = packet[2]
	local packetLength = 0
	
	--- Iterate through packet contents
	for i, isEncoded in pairs(packetIndex) do
		--- Packet data
		local data = packetData[i]
		
		--- Packet content compressed?
		if isEncoded then
			--- Is it an encoded table/string?
			if isEncoded ~= 2 then
				--- Vars
				local wasTable = (isEncoded == 1)
				local decoded, success
				
				--- Attempt to uncompress packet
				success = pcall(function()
					decoded = _L.Functions.Compress.Decode(data)
				end)
				
				--- Successfully uncompressed packet?
				if success and decoded then
					--- If table, decode from JSON
					if wasTable then
						decoded = _L.Services.HttpService:JSONDecode(decoded)
					end
					
					--- Add!
					newData[i] = decoded
					--table.insert(newData, decoded)

				else
					--- Failed to uncompress packet content
					_L.Print("Failed to decode packet argument [bold](" .. data .. ")[/bold]", true)
				end
				
			else
				--- Add nil argument
				newData[i] = nil
			end
		
		else
			--- Add!
			newData[i] = data
			--table.insert(newData, data)
		end
		
		--- Update packet length
		packetLength = i
	end

	--
	return unpack(newData, 1, packetLength)
end


--- Get (or create) BindableEvent / BindableFunction
function GetEvent(remoteName, isRemoteFunction)
	--- Variables
	remoteName = string.lower(remoteName)
	local event = events[remoteName]

	--- Check if event already exists
	if not event then
		--- Create event
		event = Instance.new(isRemoteFunction and "BindableFunction" or "BindableEvent")
		event.Name = remoteName
		event.Parent = script
		events[remoteName] = event
	end
	
	--
	return event
end


--- Get (or create) RemtoeEvent / RemoteFunction
function GetRemote(remoteName, isRemoteFunction)
	--- Variables
	remoteName = string.lower(remoteName)
	local remote = remotes:FindFirstChild(remoteName)
	
	--- Check if remote already exists
	if not remote then
		if isServer then
			--- Server -> create remote
			remote = Instance.new(isRemoteFunction and "RemoteFunction" or "RemoteEvent")
			remote.Name = remoteName
			remote.Parent = remotes
			
			--- Track remote traffic
			ListenRemote(remoteName, isRemoteFunction)
		else
			--- Client -> Tell server to create remote
			mainRemote:FireServer((isRemoteFunction and "b" or "a"), remoteName)
			
			--- Wait for remote to exist
			repeat _L.Services.RunService.RenderStepped:Wait() until remotes:FindFirstChild(remoteName)
			remote = remotes:FindFirstChild(remoteName)
			
			--- Track remote traffic
			ListenRemote(remoteName, isRemoteFunction)
		end
	end
	
	return remote
end


--- Listen for data from remotes
function ListenRemote(remoteName, isRemoteFunction)
	--- Variables
	remoteName = string.lower(remoteName)
	local remote = GetRemote(remoteName, isRemoteFunction)
	
	--- Check if remote is already being tracked
	if not listening[remoteName] then
		listening[remoteName] = true
	else
		return
	end
	
	--- Listen to remote
	if isServer then
		--- Server
		if isRemoteFunction then
			--- Remote function
			function remote.OnServerInvoke(player, ...)
				return Network.Recieve("f", remoteName, player, ...)
			end
			
		else
			--- Remote event
			remote.OnServerEvent:Connect(function(player, ...)
				Network.Recieve("e", remoteName, player, ...)
			end)
		end
	
	else
		--- Client
		if isRemoteFunction then
			--- Remote function
			function remote.OnClientInvoke(...)
				--- Signal for visualization/tracking purposes on Debug (Client only)
				if not isServer then
					_L.Signal.Fire("CORE Network Invoked", remoteName)
				end
				
				--
				return Network.Recieve("d", remoteName, ...)
			end
			
		else
			--- Remote event
			remote.OnClientEvent:Connect(function(...)
				--- Signal for visualization/tracking purposes on Debug (Client only)
				if not isServer then
					_L.Signal.Fire("CORE Network Fired", remoteName)
				end
				
				--
				Network.Recieve("c", remoteName, ...)
			end)
		end
	end
end


--- Initailize client
function ClientInit()
	--- Scan all remotes
	for _, remote in ipairs(remotes:GetChildren()) do
		if remote.Name ~= "MAIN" then
			--- Listen for traffic
			ListenRemote(remote.Name, remote:IsA("RemoteFunction"))
		end
	end
end


--- First time
if isServer then
	--- If server, listen for any traffic from MAIN remote
	mainRemote.OnServerEvent:Connect(function(player, packetType, remoteName, ...)
		Network.Recieve(packetType, remoteName, ...)
	end)

else
	--- If client, initailize
	coroutine.wrap(function()
		wait()
		ClientInit()
	end)()
end


--- Listen in on newly added remotes
remotes.ChildAdded:Connect(function(remote)
	if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then
		ListenRemote(remote.Name, remote:IsA("RemoteFunction"))
	end
end)


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

return Network